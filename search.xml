<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vim文件头配置]]></title>
    <url>%2F2019%2F02%2F21%2Fvim%E6%96%87%E4%BB%B6%E5%A4%B4%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[很多时候希望写代码的时候Vim能自动添加文件头，显示一些注释比如作者、创建时间、修改时间等等信息。事前先百度，参考了一些教程之后实际动手操作了一番，记录下我在用的代码。 修改 /etc/vimrc 文件，在末尾添加一下代码 12345678910111213141516171819202122232425262728293031323334353637383940414243" 使用&lt;F4&gt;作为触发条件map &lt;F4&gt; :call TitleDet()&lt;cr&gt;'s“ 添加文件头function AddTitle() call append(0,"/* ") call append(1," * Author : Haoojie") call append(2," * Create time : ".strftime("%Y-%m-%d %H:%M")) call append(3," * Last modified : ".strftime("%Y-%m-%d %H:%M")) call append(4," * Filename : ".expand("%:t")) call append(5," * Description : ") call append(6," */") call append(7,"") echohl WarningMsg | echo "Successful in adding the copyright." | echohl Noneendf“ 更新文件时间和描述function UpdateTitle() normal m' execute '/ * Last modified :/s@:.*$@\=strftime(": %Y-%m-%d %H:%M")@' normal '' normal mk execute '/ * Filename :/s@:.*$@\=": ".expand("%:t")@' execute "noh" normal 'k echohl WarningMsg | echo "Successful in updating the copy right." | echohl Noneendfunction“ 主函数“ 如果前8行有 Last modified，更新文件头“ 如果前8行没有 Last modified，添加文件头function TitleDet() let n=1 while n &lt; 8 let line = getline(n) if line =~ '^\s\*\sLast\smodified\s:\s*.*$' call UpdateTitle() return endif let n = n + 1 endwhile call AddTitle()endfunction 参考链接VIM 一键自动添加文件头注释]]></content>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件类型定义 DTD]]></title>
    <url>%2F2018%2F11%2F18%2F%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89-DTD%2F</url>
    <content type="text"><![CDATA[文档类型定义（DTD）可定义合法的XML文档构建模块 它使用一系列合法的元素来定义文档的结构 优点通过 DTD，每一个 XML 文件均可携带一个有关其自身格式的描述。 通过 DTD，独立的团体可一致地使用某个标准的 DTD 来交换数据。 而您的应用程序也可使用某个标准的 DTD 来验证从外部接收到的数据。 您还可以使用 DTD 来验证您自身的数据。 声明DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用 内部声明假如 DTD 被包含在 XML 源文件中，它应当通过下面的语法包装在一个 DOCTYPE 声明中： 1&lt;!DOCTYPE root-element [element-declarations]&gt; 例如 1234567891011121314&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note [&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt;]&gt;&lt;note&gt;&lt;to&gt;Tove&lt;/to&gt;&lt;from&gt;Jani&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&apos;t forget me this weekend&lt;/body&gt;&lt;/note&gt; 以上 DTD 解释如下： !DOCTYPE note (第二行)定义此文档是 note 类型的文档。 !ELEMENT note (第三行)定义 note 元素有四个元素：”to、from、heading,、body” !ELEMENT to (第四行)定义 to 元素为 “#PCDATA” 类型 !ELEMENT from (第五行)定义 from 元素为 “#PCDATA” 类型 !ELEMENT heading (第六行)定义 heading 元素为 “#PCDATA” 类型 !ELEMENT body (第七行)定义 body 元素为 “#PCDATA” 类型 外部声明假如 DTD 位于 XML 源文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中： 1&lt;!DOCTYPE root-element SYSTEM &quot;filename&quot;&gt; 例如 12345678&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE note SYSTEM "note.dtd"&gt;&lt;note&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget me this weekend!&lt;/body&gt;&lt;/note&gt; note.dtd 12345&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt; XML构建模块XML 和 HTML文档主要的构建模块是元素标签 所有的 XML 文档（以及 HTML 文档）均由以下简单的构建模块构成： 元素 元素是 XML 以及 HTML 文档的主要构建模块。 HTML 元素的例子是 “body” 和 “table”。XML 元素的例子是 “note” 和 “message” 。元素可包含文本、其他元素或者是空的。空的 HTML 元素的例子是 “hr”、”br” 以及 “img” 例如： 12&lt;body&gt;some text&lt;/body&gt;&lt;message&gt;some text&lt;/message&gt; 属性 属性可提供有关元素的额外信息。 属性总是被置于某元素的开始标签中。属性总是以名称/值的形式成对出现的。下面的 “img” 元素拥有关于源文件的额外信息： 1&lt;img src="computer.gif" /&gt; 元素的名称是 “img”。属性的名称是 “src”。属性的值是 “computer.gif”。由于元素本身为空，它被一个 “ /“ 关闭 实体 实体是用来定义普通文本的变量。实体引用是对实体的引用。 大多数同学都了解这个 HTML 实体引用：”&amp;nbsp(破坏实体);”。这个”无折行空格”实体在 HTML 中被用于在某个文档中插入一个额外的空格。 当文档被 XML 解析器解析时，实体就会被展开。 例如: &amp;lt(破坏实体);的对应字符为&lt; &amp;gt(破坏实体);的对应字符为&gt; &amp;amp(破坏实体);的对应字符为&amp; &amp;quot(破坏实体);的对应字符为” &amp;apos(破坏实体);的对应字符为’ PCDATA PCDATA 的意思是被解析的字符数据（parsed character data）。 可把字符数据想象为 XML 元素的开始标签与结束标签之间的文本。 PCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。 文本中的标签会被当作标记来处理，而实体会被展开。 不过，被解析的字符数据不应当包含任何 &amp;、&lt; 或者 &gt; 字符；需要使用 &amp;amp(破坏实体);、&amp;lt(破坏实体); 以及 &amp;gt(破坏实体); 实体来分别替换它们。 CDATA CDATA 的意思是字符数据（character data）。 CDATA 是不会被解析器解析的文本。在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开 DTD元素在一个 DTD 中，元素通过元素声明来进行声明 元素声明使用下面的语法： 123&lt;!ELEMENT element-name category&gt;或&lt;!ELEMENT element-name (element-content)&gt; 空元素通过类别关键词EMPTY进行声明 123456&lt;!ELEMENT element-name EMPTY&gt;实例:&lt;!ELEMENT br EMPTY&gt;XML example:&lt;br /&gt; 只有 PCDATA 的元素通过圆括号中的 #PCDATA 进行声明： 123&lt;!ELEMENT element-name (#PCDATA)&gt;实例:&lt;!ELEMENT from (#PCDATA)&gt; 通过类别关键词 ANY 声明的元素，可包含任何可解析数据的组合： 123&lt;!ELEMENT element-name ANY&gt;实例:&lt;!ELEMENT note ANY&gt; 带有一个或多个子元素的元素通过圆括号中的子元素名进行声明： 123456&lt;!ELEMENT element-name (child1)&gt;或&lt;!ELEMENT element-name (child1,child2,...)&gt;实例:&lt;!ELEMENT note (to,from,heading,body)&gt; 当子元素按照由逗号分隔开的序列进行声明时，这些子元素必须按照相同的顺序出现在文档中。在一个完整的声明中，子元素也必须被声明，同时子元素也可拥有子元素。”note” 元素的完整声明是： 12345&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt; 声明只出现一次的元素 1234&lt;!ELEMENT element-name (child-name)&gt;实例:&lt;!ELEMENT note (message)&gt; 上面的例子声明了：message 子元素必须出现一次，并且必须只在 “note” 元素中出现一次 声明最少出现一次的元素 1234&lt;!ELEMENT element-name (child-name+)&gt;实例:&lt;!ELEMENT note (message+)&gt; 上面的例子中的加号（+）声明了：message 子元素必须在 “note” 元素内出现至少一次 声明出现零次或一次的元素 1234&lt;!ELEMENT element-name (child-name?)&gt;实例:&lt;!ELEMENT note (message?)&gt; 上面的例子中的问号(?)声明了：子元素 message 可在 “note” 元素内出现零次或一次 声明出现零次或多次的元素 1234&lt;!ELEMENT element-name (child-name*)&gt;实例:&lt;!ELEMENT note (message*)&gt; 上面的例子中的星号（*）声明了：子元素 message 可在 “note” 元素内出现零次或多次 声明“非···/即···”类型的内容 12实例:&lt;!ELEMENT note (to,from,header,(message|body))&gt; 声明混合型的内容 12实例:&lt;!ELEMENT note (#PCDATA|to|from|header|message)*&gt; 上面的例子声明了：”note” 元素可包含出现零次或多次的 PCDATA、”to”、”from”、”header” 或者 “message” DTD属性在 DTD 中，属性通过 ATTLIST 声明来进行声明 示例： 1234567&lt;!ATTLIST element-name attribute-name attribute-type attribute-value&gt;DTD 实例:&lt;!ATTLIST payment type CDATA &quot;check&quot;&gt;XML 实例:&lt;payment type=&quot;check&quot; /&gt; 属性的类型 类型 描述 CDATA 值为字符数据 (character data) (en1\ en2\ ..) 此值是枚举列表中的一个值 ID 值为唯一的 id IDREF 值为另外一个元素的 id IDREFS 值为其他 id 的列表 NMTOKEN 值为合法的 XML 名称 NMTOKENS 值为合法的 XML 名称的列表 ENTITY 值是一个实体 ENTITIES 值是一个实体列表 NOTATION 此值是符号的名称 xml: 值是一个预定义的 XML 值 默认属性值可用以下值 值 解释 值 属性的默认值 #REQUIRED 属性值是必需的 #IMPLIED 属性不是必需的 #FIXED value 属性值是固定的 例如： 123456DTD:&lt;!ELEMENT square EMPTY&gt;&lt;!ATTLIST square width CDATA &quot;0&quot;&gt;合法的 XML:&lt;square width=&quot;100&quot; /&gt; 在上面的例子中，”square” 被定义为带有 CDATA 类型的 “width” 属性的空元素。如果宽度没有被设定，其默认值为0 #REQUIRED语法 1&lt;!ATTLIST element-name attribute-name attribute-type #REQUIRED&gt;· 示例：12345678DTD:&lt;!ATTLIST person number CDATA #REQUIRED&gt;合法的 XML:&lt;person number=&quot;5677&quot; /&gt;非法的 XML:&lt;person /&gt; #IMPLED语法 1&lt;!ATTLIST element-name attribute-name attribute-type #IMPLIED&gt; 示例： 12345678DTD:&lt;!ATTLIST contact fax CDATA #IMPLIED&gt;合法的 XML:&lt;contact fax=&quot;555-667788&quot; /&gt;合法的 XML:&lt;contact /&gt; #FIXED语法 1&lt;!ATTLIST element-name attribute-name attribute-type #FIXED &quot;value&quot;&gt; 实例 12345678DTD:&lt;!ATTLIST sender company CDATA #FIXED &quot;Microsoft&quot;&gt;合法的 XML:&lt;sender company=&quot;Microsoft&quot; /&gt;非法的 XML:&lt;sender company=&quot;W3Schools&quot; /&gt; 列举属性值语法 1&lt;!ATTLIST element-name attribute-name (en1|en2|..) default-value&gt; 实例 1234567DTD:&lt;!ATTLIST payment type (check|cash) &quot;cash&quot;&gt;XML 例子:&lt;payment type=&quot;check&quot; /&gt;或&lt;payment type=&quot;cash&quot; /&gt; 如果您希望属性值为一系列固定的合法值之一，请使用列举属性值。(男|女) 元素&amp;属性xml中数据可以存储在子元素或属性中 例： 1234&lt;person sex="female"&gt; &lt;firstname&gt;Anna&lt;/firstname&gt; &lt;lastname&gt;Smith&lt;/lastname&gt;&lt;/person&gt; 12345&lt;person&gt; &lt;sex&gt;female&lt;/sex&gt; &lt;firstname&gt;Anna&lt;/firstname&gt; &lt;lastname&gt;Smith&lt;/lastname&gt;&lt;/person&gt; 没有特别规定何时使用属性，以及何时使用子元素。 一些属性具有以下问题: 属性不能包含多个值（子元素可以） 属性不容易扩展（为以后需求的变化） 属性无法描述结构（子元素可以） 属性更难以操纵程序代码 属性值是不容易测试，针对DTD 如果您使用属性作为数据容器，最终的XML文档将难以阅读和维护。 尝试使用元素来描述数据。只有在提供的数据是不相关信息时我们才建议使用属性。 例外：唯一标识符ID 123456789101112131415&lt;messages&gt;&lt;note id="p501"&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget me this weekend!&lt;/body&gt;&lt;/note&gt;&lt;note id="p502"&gt; &lt;to&gt;Jani&lt;/to&gt; &lt;from&gt;Tove&lt;/from&gt; &lt;heading&gt;Re: Reminder&lt;/heading&gt; &lt;body&gt;I will not!&lt;/body&gt;&lt;/note&gt;&lt;/messages&gt; 以上实例的XML文件中，ID是只是一个计数器，或一个唯一的标识符，来识别不同的音符，而不是作为数据的一部分。 在这里我想说的是，元数据（关于数据的数据）应当存储为属性，而数据本身应当存储为元素。 实体实体是用于定义引用普通文本或特殊字符的快捷方式的变量。 实体引用是对实体的引用。 实体可在内部或外部进行声明。 内部声明语法 12345678910&lt;!ENTITY entity-name &quot;entity-value&quot;&gt;示例：DTD 实例:&lt;!ENTITY writer &quot;Donald Duck.&quot;&gt;&lt;!ENTITY copyright &quot;Copyright runoob.com&quot;&gt;XML 实例：&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt; 注意： 一个实体由三部分构成: 一个和号 (&amp;), 一个实体名称, 以及一个分号 (;)。 外部声明语法 12345678910&lt;!ENTITY entity-name SYSTEM &quot;URI/URL&quot;&gt;示例：DTD 实例&lt;!ENTITY writer SYSTEM &quot;http://www.runoob.com/entities.dtd&quot;&gt;&lt;!ENTITY copyright SYSTEM &quot;http://www.runoob.com/entities.dtd&quot;&gt;XML example:&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt; 验证当您试图打开某个 XML 文档时，XML 解析器有可能会产生错误。通过访问 parseError 对象，就可以取回引起错误的确切代码、文本甚至所在的行。 XML格式验证(菜鸟教程)]]></content>
      <tags>
        <tag>DTD</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聚类]]></title>
    <url>%2F2018%2F10%2F10%2F%E8%81%9A%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Data Science and Big Data Analytics: Discovering, Analyzing, Visualizing and Presenting Data 的第四章 目的 查找相似的文件/网站/图片 使用实例：冗余网站、查重等 社交网络分析 网易云音乐推荐、Netflix个性化推荐 差异分析两个文本之间的相似度衡量 Hamming Distance (汉明距离) Distance Functions（距离函数） Jaccard similarity 相似性系数 Hamming Distance 汉明距离在信息理论中，Hamming Distance 表示两个等长字符串在对应位置上不同字符的数目，我们以 d(x, y) 表示字符串x和y之间的汉明距离。从另外一个方面看，汉明距离度量了通过替换字符的方式将字符串 x 变成 y 所需要的最小的替换次数。 123456789101112131415161718192021// 举例说明以下字符串间的汉明距离为：PETERPUGET is 3.karolinkathrin is 3. karolinkerstin is 3.10111011001001 is 2.21738962233796 is 3.123456234561 is 6.GE2324CS2423 is 4. Euclidean Distance 欧几里得度量（欧式距离）欧氏距离是指在 m 维空间中两个点之间的真实距离，或者向量的自然长度（即该点到原点的距离）。m 维空间中两个点之间的真实距离（不管是一维还是二维、三维，都是代表着真实的距离）。 两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的欧氏距离为 在二维空间中欧氏距离计算公式为： 示例： 上图中各点的坐标为： p1 = (0, 2)p2 = (2, 0)p3 = (3, 1)p4 = (5, 1) 各点间欧氏距离为： P1 P2 P3 P4 P1 0 2.828 3.162 5.099 P2 2.828 0 1.414 3.162 P3 3.162 1.414 0 2 P4 5.099 3.162 2 0 Manhattan Distance 曼哈顿距离我们可以定义曼哈顿距离的正式意义为 L1 - 距离或城市区块距离，也就是在欧几里得空间的固定直角坐标系上两点所形成的线段对轴产生的投影的距离总和。例如在平面上，坐标（x1,y1）的点 P1 与坐标（x2, y2）的点 P2 的曼哈顿距离为：|x1-x2|+|y1-y2|，要注意的是，曼哈顿距离依赖座标系统的转度，而非系统在座标轴上的平移或映射。 两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的曼哈顿距离为 在二维空间中曼哈顿距离计算公式为： 示例： a1 = (2, 8)a2 = (6, 3) dist = |2-6| + |8-3| = 4+5 = 9 距离度量函数一个函数 d 是距离度量函数需要具备以下条件 非负，d(a, b) &gt;= 0 恒等，if (a==b) d(a, b) = 0 对称，d(a, b) = d(b, a) 三角不等式，d(a, b) &lt;= d(a, c) + d(c, b) 1. 聚类概述聚类：使用无监督学习对类似对象进行分组 监督学习：使用带有标签的物体无监督学习：使用不带标签的物体 聚类查找数据中的隐藏结构，基于属性的相似性，通常用于探索性分析且没有预测 什么是聚类针对一组数据对象做处理，使得组内的对象彼此相似（或相关）并且与其他组中的对象不同（或不相关），即组内距离最小化、组间距离最大化 对对象（受访者，产品，公司，变量等）进行分组，以便每个对象与类中的其他对象类似，并且与所有其他类中的对象不同。 示例： 我们可以用聚类干什么 确定集群的含义 解释如何使用集群 聚类设计注意事项： 异常值检测 相似度/距离测量 三个基本的问题： 如何衡量相似度？ 距离算法 如何形成集群？ 层次聚类（Hierarchical Clustering）、K-means算法等 有多少个集群？ 验证聚类，检查连个、三个、四个甚至更多集群的聚类解决方案 根据 “先验” 标准、实际判断、常识、理论基础和统计意义选择集群数 概念步骤： 确定要聚类的变量 确定是否存在集群。 需要验证集群在统计上是否不同且理论上有意义（可以分配逻辑名称） 初步决定要使用的集群数量 使用人口统计学，心理学等描述派生集群的特征 示例： 埃里克和他的朋友们聚会， 他们决定分享他们收藏的葡萄酒。问如何分类这些葡萄酒？ 列出葡萄酒的属性，在其中选择聚类特征变量。 在这种情况下，我们选择评级和价格 将表转换为散点图 我们可以说有两个集群：低评级和低价格、高评级和高价格 决定使用这两个集群 进行聚类 但是有一个异常值 2. 聚类的两种类型划分聚类（Partitional algorithms）：构造各种分区，然后按一些标准评估它们层次聚类（Hierarchical algorithms）：使用某个标准（通常为距离）创建对象集的层次分级 K-means（基于划分的聚类 Partitional algorithms）给定一组具有 n 个可测量属性的对象的数据集和集群的划分数量 k，该算法根据每个对象到这 k 个组的中心的邻近长度区分这 k 个组 采用迭代的重定位技术，尝试通过对象在划分间移动来改进划分。所谓重定位技术，就是当有新的对象加入簇或者已有对象离开簇的时候，重新计算簇的平均值作为中心（簇中对象各维向量的平均值），然后对对象进行重新分配。这个过程不断重复，直到各簇中对象不再变化为止。 使用示例： 聚类通常被应用于以属性作为标识的集群的分类 图像处理：对于安全图像，检查连续帧以区分修改 医疗：可以将患者按照先天因素分组 客户划分：销售团队区分具有相似行为和消费模式的客户 K-means的步骤概述： 选择 k 的值和聚类中心的初始猜测值 计算从每个数据点到每个聚类中心的距离，并将每个点分配给最近的类 从步骤2计算每个新定义的集群的聚类中心 重复步骤2和3，直到算法收敛（不发生更改） 示例1： 设置 k = 3 和初始聚类中心 点被分配给最近的类（根据点到聚类中心的距离分配） 计算新集群的聚类中心 重复第2、3步直到收敛当聚类中心不改变或聚类中心来回振荡时收敛（当一个或多个点与聚类中心距离相等时，可能会发生这种情况） 基本的 K-means 算法： 选择要确定的 K 个集群 随机选择 K 个对象作为初始聚类中心 重复 3 将每个对象分配给最近的集群 计算每个集群新的聚类中心 直到 集群中心没有变化（即聚类中心不再改变位置） 或者 没有对象更改其集群（我们也可以定义停止条件） 示例2： 算法：K-means 距离度量：Euclidean Distance 欧几里得度量（欧式距离） 确定集群的数量并随机设置相同数量的 k 个节点（聚类中心） 根据它们到 k 个节点的距离对所有对象进行聚类。 然后重新设置第1步产生的 k 个节点（聚类中心） 根据每个对象到k个节点的距离重新聚类 重新设置 k 个节点（聚类中心），即将k个节点移动到其集群的中心 重复步骤3和4，直到 k 个节点不改变位置 示例3： 现有学生成绩如下图： 绘制散点图如下： 初始化三个中心： 将每个学生分配到最近的中心： 重新计算第一个中心 (54, 42)、(70, 57)、(69, 61)、(68, 66)、(88, 71)、(89, 74)、(74, 72)、(83, 83) 的平均值为 (74.38, 65.75) 重新计算第二个中心 (41, 43)、(45, 50) 的平均值为 (43.00, 46.50) 重新计算第三个中心 (56, 55)、(58, 58)、(63, 64)、(48, 65)、(72, 79)、(60, 83)、(86, 91)、(92, 97)、 (94, 100) 的平均值为 (69.89, 76.89) 重新分配每个学生最近的中心 重新计算第一个中心 (70, 57)、(58, 58)、(69, 61)、(63, 64)、(68, 66)、(88, 71)、(89, 74)、(74, 72) 的平均值为 (72.38, 65.38) 重新计算第二个中心 (54, 42)、 (41, 43)、(45, 50) 、(56, 55)、(48, 65) 的平均值为 (48.80, 51.00) 重新计算第三个中心 (72, 79)、(60, 83)、(83, 83)、(86, 91)、(92, 97)、 (94, 100) 的平均值为 (81.17, 88.83) 重新分配每个学生最近的中心，重新计算第一个中心 (70, 57)、(69, 61)、(63, 64)、(68, 66)、(88, 71)、(74, 72)、(60, 83) 的平均值为 (70.29, 67.71) 重新计算第二个中心 (54, 42)、 (41, 43)、(45, 50) 、(56, 55)、(58, 58)、(48, 65) 的平均值为 (50.33, 52.17) 重新计算第三个中心 (89, 74)、(72, 79)、(83, 83)、(86, 91)、(92, 97)、 (94, 100) 的平均值为 (86.00, 87.33) 重新分配每个学生最近的中心，重新计算第一个中心为 (68.00, 68.86)、第二个中心为 (50.33, 52.17)、第三个中心为 (88.67, 86.00) 最终分组为： K-means 的局限性：非球形体 解决： 优缺点分析： 优点： 相对有效 通常终止于局部最优。 只能找到固定数量的簇的最佳解决方案。 无法找到所有可能解决方案中的最佳解决方案。 在确定性退火技术（deterministic annealing）和遗传算法（genetic algorithms）和可能找到全局最优解 缺点： 仅在定义平均值时适用，那么分类数据呢？ 需要事先指定 k，集群的数量 无法处理乱的数据和异常值 不适合发现具有非凸形状的集群 Hierarchical Clustering（层次聚类）层次结构通常用于组织信息，例如在门户网站中 示例1：雅虎 雅虎的层次结构是手动创建的，我们将专注于自动创建数据挖掘中的层次结构。 用于总结相似性度量的有用工具——树形图 树形图中两个对象之间的相似性表示为它们共享的最低内部节点的高度。 我们可以查看树形图以确定“正确”的簇数。 在这种情况下，两个高度分离的子树高度暗示了两个簇。 （很少出现这种情况） 示例2： 树形图的一个潜在用途是检测异常值 ，单个独立的分支暗示了与所有其他分支非常不同的数据点 示例3： 单连接算法（Single-Linkage） 我们从距离矩阵开始，该矩阵包含数据库中每对对象之间的距离。 示例4： 自下而上（凝聚）：从其自己的集群中的每个项目开始，找到要合并到新集群中的最佳对。 重复，直到所有集群都融合在一起。 什么是好的聚类算法 一个好的聚类算法将产生具有组内相似度高、组间相似度低的集群 准确定义聚类算法的质量很困难，通常是依赖应用的并且是主观的 为什么要使用聚类 它的主要任务是探索性数据挖掘，也是统计数据分析的常用技术，可以应用于许多领域以及现实生活中 实际上，聚类是最常用的数据挖掘技术之一。它历史悠久，几乎用于各个领域，如工程，科学，医学，心理学，植物学，社会学，生物学，考古学，市场营销，保险，图书馆等 举例 为不同高度、不同体重的人制作大中小型号的衣服（XS、S、M、L、XL、XXL 等） 为所有人定制太贵，一刀切又不适合所有人 在营销中，根据客户的相似性对客户进行细分。做针对性的营销 给定一组文本文档，我们希望根据它们的内容相似性来组织它们，生成主题层次结构（书店中书的排列） 实际应用 便于理解：相关文档及参考文献，具有相似功能的基因组和蛋白质，或具有相似价格波动的股票组 概要展示：减小大数据集的大小。天气预报中的气温图、降雨图 例1：人群（物体）的划分 辛普森一家和学校的员工 男和女 例2： 3. 如何确定集群的最佳数量 合理的猜测 预定义的要求 使用启发式方法 - 例如，内部平方和（WSS） WSS度量是每个数据点与最近聚类中心之间的距离的平方和识别 k 的适当值的过程被称为找到 WSS 曲线的拐点（WSS为纵坐标，集群数量为横坐标） 曲线的拐点发生在 K = 3 的时候 检验 当集群的数量很小时，绘制数据有助于改进 k 的选择 需要注意 集群是否完全分离？ 所有集群中都只有少量的对象？ 所有集群的聚类中心是不是太接近了？ 选择理由和注意事项 需要做决定 分析中应该包含对象的哪些属性？ 每个属性应该使用哪种度量单位？ 属性是否需要重新调整？ 可能还有哪些其他需要考虑的因素？ 了解要知道哪些属性才能把新对象分配给集群 客户满意度可用于建模，但不适用于潜在客户 尽可能减少属性数量 多属性可以最大限度地减少关键变量的影响 找出高度相关的属性 将几个属性合并为一个：例如，债务/资产比率 例如：7个属性的散点图矩阵如下： 计量单位 K-means 将根据度量单位识别不同的集群 示例： 身高使用 cm 为单位 身高使用 m 为单位 重新调整可以减少统治效果 例如，将每个变量除以适当的标准偏差 其它考虑因素 K-means对初始聚类中心敏感（替换聚类中心重新运行几次） 可以探索欧氏距离以外的其它度量算法，如汉明距离、曼哈顿距离、马氏距离（Mahalanobis distance） K-means 适用于数字数据，并且不适用于名词属性，如性别，种族，血型，单词，形状，水果…… 4. R语言指令12345678# K-means 聚类算法kmeans()# K-modes 聚类算法kmod()# Partitioning around Medoids (PAM) 算法pam()# Hierarchical agglomerative clustering 层次聚类hclust() 5. 总结 聚类根据对象的属性对类似对象进行分组 要正确聚类，重要的是 正确缩放属性值以避免压迫（覆盖） 确保指定距离的概念是有意义的 仔细选择群集数量 识别出集群后，以描述性方式标记集群通常很有用 6. 高中生聚类分析]]></content>
      <tags>
        <tag>聚类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HMAC算法]]></title>
    <url>%2F2018%2F10%2F09%2FHMAC%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在密码学中，（消息认证码）Message Authentication Code 是用来认证消息的比较短的信息。换言之，MAC用来保证消息的数据完整性和消息的数据源认证 MAC由消息本身和一个密钥经过一系列计算产生，用于生成MAC的算法，称为MAC算法。 MAC算法应能满足如下几个条件: 在仅有消息本身没有密钥的情况下，无法得到该消息的 MAC 同一个消息在使用不同密钥的情况下，生成的 MAC 应当无关联 在已有一系列消息以及其 MAC 时，给定一个新的消息，无法得到该消息的 MAC 上图为维基百科上 MAC 算法使用示例。 HMACHMAC（Hash-based Message Authentication Code，哈希消息认证码）利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出 HMAC 是 IP 安全里必须实现的 MAC 方案，并且其他 Internet 协议中（如SSL）也使用了 HMAC。 HMAC的设计目标 可以直接使用现成的 Hash 函数 很容易用更好地 Hash 函数替代原来嵌入的 Hash 函数 能够保持 Hash 函数的原有性能，不能过分降低其性能 对密钥的使用和处理应较简单 如果已知嵌入的 Hash 函数的强度，完全可以知道认证机制抗密码分析的强度 正是 HMAC 的这些设计目标保证了HMAC的灵活性、可用性和扩展性，从而得到了广泛的支持。 定义 HMAC 需要一个加密用散列函数（表示为 H，可以是 MD5 或者 SHA-1）和一个密钥 K。我们用 B 来表示数据块的字节数。（以上所提到的散列函数的分割数据块字长 B=64），用 L 来表示散列函数的输出数据字节数（MD5 中 L=16, SHA-1 中 L=20）。鉴别密钥的长度可以是小于等于数据块字长的任何正整数值。应用程序中使用的密钥长度若是比 B 大，则首先用使用散列函数 H 作用于它，然后用 H 输出的L长度字符串作为在 HMAC 中实际使用的密钥。 一般情况下，推荐的最小密钥 K 长度是 L 个字节。 算法表示算法公式 ： HMAC( K, M ) = H( K⊕Opad | H( K⊕Ipad | M) ) H 代表所采用的HASH算法(如SHA-256) K 代表认证密钥 Ko 代表HASH算法的密文 M 代表一个消息输入 B 代表H中所处理的块大小，这个大小是处理块大小，而不是输出 hash 的大小 如，SHA-1 和 SHA-256 B = 64 SHA-384 和 SHA-512 B = 128 L 表示 hash 的大小 Opad 用 0x5c 重复 B 次 Ipad 用 0x36 重复 B 次 Apad 用 0x878FE1F3 重复 (L/4) 次 HMAC运算步骤First-Hash = H( Ko XOR Ipad || (data to auth) ) Second-Hash = H( Ko XOR Opad || First-Hash) 在密钥 K 后面添加0来创建一个字长为 B 的字符串。(例如，如果 K 的字长是20字节，B=64 字节，则K后会加入44个零字节0x00) 将上一步生成的 B 字长的字符串与 ipad 做异或运算 将数据流 text 填充至第二步的结果字符串中 用 H 作用于第三步生成的数据流 将第一步生成的 B 字长字符串与 opad 做异或运算 再将第四步的结果填充进第五步的结果中 用 H 作用于第六步生成的数据流，输出最终结果 HMAC的应用HMAC 主要应用在身份验证中，它的使用方法是这样的： 客户端发出登录请求（假设是浏览器的GET请求） 服务器返回一个随机值，并在会话中记录这个随机值 客户端将该随机值作为密钥，用户密码进行 HMAC 运算，然后提交给服务器 服务器读取用户数据库中的用户密码和步骤2中发送的随机值做与客户端一样的 HMAC 运算，然后与用户发送的结果比较，如果结果一致则验证用户合法 在这个过程中，可能遭到安全攻击的是服务器发送的随机值和用户发送的 HMAC 结果，而对于截获了这两个值的黑客而言这两个值是没有意义的，绝无获取用户密码的可能性。 随机值的引入使 HMAC 只在当前会话中有效，大大增强了安全性和实用性。 参考链接Message authentication code MAC与HMAC介绍 HMAC]]></content>
      <tags>
        <tag>安全协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DH(Diffie–Hellman)算法]]></title>
    <url>%2F2018%2F10%2F09%2FDH-Diffie%E2%80%93Hellman-%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[DH 是 Diffie-Hellman的首字母缩写，是Whitefield与Martin Hellman在1976年提出了一个的密钥协商协议。其安全性源于在有限域上计算离散对数。该算法可以使两个用户之间安全地交换一个密钥，但不能用于加密或解密信息。 原理： Alice和Bob首先约定好公开的一种颜色，比如黄色 Alice和Bob各自挑选出一种私密的颜色，比如橙色和青色 Alice和Bob各自将两种颜色混合起来 双方交换混合后的颜色 Alice和Bob各自将自己的私密颜色再次混入得到的颜色中 现在Alice和Bob得到了一种相同的颜色，这种颜色是由一份黄色、一份橙色、一份青色混合而来，但外界无法得知 颜色混合是一种“不可逆”的操作，当双方交换颜色时，尽管我们知道他们交换的颜色都是由一份黄色和另一份其他颜色混合得到的，但我们还是无法或者很难得到他们的私密颜色。而DH秘钥交换的原理非常相似，也是利用了数学上的一个“不可逆”的运算，就是离散对数 乘方得逆运算称为对数运算，比如已知 7^x = 49 那么可知 x = log7 49 = 2 对数运算非常容易，即使在数字很大的时候是，但如果是下面的情况 7^x mod 13 = 8 求X的过程称为“离散对数”，就不那么容易了，在数字很大时几乎是一个不可能的运算，而DH秘钥交换就是利用了这种离散对数计算非常困难的特性来设计的。 公式里的mod是取模运算，取模运算有几条基本的定律如下 (a+b) mod P = (a mod P + b mod P) mod P (ab) mod P = (a mod P b mod P) mod P (a^b) mod P = ((a mod P)^b) mod P 根据上面的公式，可以推导出一个非常重要的公式 (G^(a*b)) mod P = (G^a mod P)^b mod P = (G^b mod P)^a mod P 根据这个公式，我们可以向上面交换颜色那样设计出一个秘密交换数字的流程出来 A和B首先约定两个公开的质数 p 和 g A和B各自随机产生两个数 a, b，作为自己的私钥 各自计算出自己的公钥 A, B A = g^a mod p B = g^b mod p 交换公钥 A, B 计算出加密用的密钥S Sa=B^a mod p=(g^b mod p)^a mod p=g^(a*b) mod p Sb=A^b mod p=(g^a mod p)^b mod p=g^(a*b) mod p 最终两个人得到的秘密数字都是 g^(ab) mod p，而窃听者仅从p, g, A, B四个公开信息，是无法得到这个秘密数字的 举个例子，假如 p=23，g=5，Alice选取的秘密数字 a=6，那么 A=5^6 mod 23=8，Bob选取的秘密数字是 b=15，那么 B=5^15 mod 23=19，交换A和B后，Alice计算出的密钥 Sa=19^6 mod 23=2，Bob计算出的密钥 Sb=8^15 mod 23=2当然，实际运算中不可能取这么小的数值，比如如果需要128bit长度的密钥，那么p值需要是128bit长度的质数，由于有模运算，所获得的密钥不会大于p，所以p值可以是128bit数字中最大的一个质数，g可以随便设置一个小的质数即可。 缺点如果注意的是，为了防止应用优化算法计算上述问题，质数p不是随便选择的，需要符合一定的条件。 随机数a、b的生成算法也必需注意，应使结果尽可能随机，不能出现可预测的规律，否则会使破解变的容易。 通过上述计算过程也可以看出DH算法不仅可以应用在2方通信的情况，如果多方通信，也可以使用该算法。 DH密钥交换算法无法验证对方身份，所以DH密钥交换算法不能抵御中间人攻击 DH算法中间人攻击原理： 从其原理之中可以看出，a，b 值并没有什么关系，a，b不能证明通信双方Alice与Bob的身份，这使得重放攻击可以轻易产生。 假设一个攻击者 Tom，当 Alice 向 Bob 发送 g, p, A 时，Tom 截获了信息，并（假装自己是 Bob）向 Alice 发送了 T=g^t mod p，其中 t 是 Tom 的私钥。同时 Tom（假装自己是 Alice）向 Bob 发送 g，p，T=g^t mod p，这样 Bob 以为这是 Alice 发过来的，就向 T 发送了 B=g^b mod p。 在 Alice 与 Tom 之间，创建的密钥就是 Sta=g^at mod p，两方密钥相同。 在 Tom 与 Bob 之间，创建的密钥就是 Stb=g^tb mod p，两方密钥相同。 这样，密钥创建完成，Alice 与 Bob 都认为自己与对方分享了只有他们两人所知的密钥，实际上并不是。当 Alice 想要发信息给 Bob 时，Alice 就会将信息用 Sta=g^at mod p 加密后发出，消息 Bob 无法解密，但会被 Tom 收到并解密，这样 Tom 可以或者扣留信息，或者篡改信息用 Stb=g^tb mod p 加密后发给 Bob，这样 Bob 会收到他认为是 Alice 发来的，其实是 Tom 发过来的经过篡改的信息。这样重放攻击就产生了。 解决： 可以采用数据签名技术解决中DH密钥交换过程中可能存在的中间人攻击 参考链接链接： DH密钥交换（Diffie–Hellman key exchange）算法笔记 一个简单的DH密钥协商算法的实现 Diffie–Hellman key exchange 关于Diffie-Hellman密钥协商机制以及中间人攻击]]></content>
      <tags>
        <tag>安全协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂算法]]></title>
    <url>%2F2018%2F10%2F09%2F%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[平方乘算法RSA 加解密中存在指数运算 X^a。通常解密运算中的指数非常大，a 的二进制位数通常会大于等于1024 bit，即可能 a &gt;= 2^1024。如果用一般方法直接计算 X^a 的值， 即 X*X*X……需要的运算量非常大，很容易溢出。 定义：MUL 为乘法运算即乘以 X，sq 为平方运算 考虑一个例子计算 X^8，则最简单的方法需要8次乘法运算 而更快捷的方法只需要3次平方运算在看一个更一般的例子，计算 X^24，最简单的方法就是计算24次乘法。 更有效的方法如下：即一次平方操作，一次乘法操作(乘以 X)，之后再三次平放操作。 即5次操作即可得到结果也就是说对于指数运算两种基本操作就可以得到结果：对当前结果平方，当前结果与 X 相乘。问题是如何确定平方与乘法的执行顺序, 平方-乘算法就可以解决这个问题。 大致描述为： 对 X^a 将指数 a 表示为2进制形式，高bit在左，然后从左至右扫描对应的 bit 位。除了最左边的 bit（MSB）以外，在扫描之后每个 bit 位时对当前结果平方，如果该bit位为1，则需多进行一次乘法操作 以计算 X^24 为例： 黑体表示二进制形式 X^24 将指数表示为二进制形式 X^11000 表示为 X^b1b2b3b4b5 开始扫描指数的每个Bit: 初始值 X = X^1; 初始化设置，b1 = 1，扫描第一个bit时不需要做其他操作 X^2 = X^11 b2=1，先平方 X^2*X = X^3 = X11 ，再乘以 X (X^3)^2 = X^6 = X^110 b3= 0，只需要一次平方 (X^6)^2 = X^12 = X^1100 b4 = 0，只需要一次平方 (X^12)^2 = X^24 = X^11000 b5 = 0,只需一次平方 通过观察运算过程中指数的二进制表示的变化能更好的理解算法，一次平方操作会让指数向左移一位，并在最右边添加0，而与 X 相乘的操作即在指数的最右边位置上填上 1 快速幂算法所谓的快速幂，实际上是快速幂取模的缩写，简单的说，就是快速的求一个幂式的模(余)。在程序设计过程中，经常要去求一些大数对于某个数的余数，为了得到更快、计算范围更大的算法，产生了快速幂取模算法。 快速幂实现基于引理：积的取余等于取余的积的取余，即： (a * b) mod n=(a mod n * b mod n) mod n 示例：4^24 mod 102 = 52 24 = 11000 4^24 mod 102 = ( ( ( ( (4^1)*(4^1)^2 ) ^2) ^2) ^2) mod 102 ​ = ( ( ( 64 ^2) ^2) ^2) mod 102 ​ = ( ( ( 64 ^2) ^2) mod 102) ^2 mod 102 ​ = ( ( ( 64 ^2) mod 102)^2 mod 102) ^2 mod 102 ​ = ( ( 256 mod 102)^2 mod 102) ^2 mod 102 ​ = ( 52^2 mod 102) ^2 mod 102 ​ = ( 52^2) mod 102 ​ = 52]]></content>
      <tags>
        <tag>密码学</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F27%2FHello-World%2F</url>
    <content type="text"><![CDATA[1234567#include &lt;stdio.h&gt;int main(void)&#123; printf("Hello World\n"); return 0;&#125;]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
